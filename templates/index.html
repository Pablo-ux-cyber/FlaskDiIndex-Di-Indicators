<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>DI Index – Объединённые данные</title>
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
  <script src="https://unpkg.com/lightweight-charts@3.8.0/dist/lightweight-charts.standalone.production.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <style>
    body { font-family: Arial, sans-serif; }
    .coin-container { margin-bottom: 40px; }
    table { border-collapse: collapse; width: 100%; margin-top: 20px; }
    th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
    th { background-color: #f2f2f2; position: sticky; top: 0; z-index: 1; cursor: pointer; }
    th:hover { background-color: #e6e6e6; }
    tr:hover { background-color: #e0f7fa; }
    tr.no-4h { background-color: #fff3e0; }
    tr.no-4h:hover { background-color: #ffe0b2; }
    caption { margin-bottom: 10px; font-size: 1.4em; font-weight: bold; }
    #error { color: red; font-weight: bold; margin-top: 20px; white-space: pre-wrap; }
    .symbol-selector { margin: 20px 0; }
    #loading { font-size: 1.2em; margin: 20px 0; }
    select[multiple] { min-width: 200px; height: 300px; }
    .loading-indicator { color: #666; font-style: italic; margin-left: 10px; }
    .control-buttons { margin: 10px 0; }
    .btn { 
      padding: 5px 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background-color: #6c757d;
      color: white;
    }
    .btn:hover {
      background-color: #5a6268;
    }
    .diff-highlight {
      background-color: rgba(255, 244, 229, 0.3);
    }
    .comparison-group {
      border-right: 2px solid #ddd;
    }
    thead tr th.group-header {
      text-align: center;
      background-color: #e9ecef;
      font-weight: bold;
    }
    .nav-tabs {
      margin-bottom: 20px;
    }
    .nav-tabs .nav-link {
      color: #495057;
      font-weight: 500;
    }
    .nav-tabs .nav-link.active {
      color: #007bff;
      border-color: #dee2e6 #dee2e6 #fff;
    }
    .tab-content {
      padding: 20px 0;
    }
    .tab-pane {
      display: none;
    }
    .tab-pane.active {
      display: block;
    }
    .chart-container {
      position: relative;
      height: 400px;
      width: 100%;
      margin-top: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      border-radius: 4px;
      overflow: hidden;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="container-fluid">
    <h1 class="my-4">DI Index – Объединённые данные</h1>

    <!-- Селектор символов -->
    <div class="symbol-selector">
      <label for="symbols">Выберите криптовалюты:</label>
      <select id="symbols" multiple>
        <option value="BTC" selected>Биткоин (BTC)</option>
        <option value="ETH">Эфириум (ETH)</option>
        <option value="XRP">XRP (XRP)</option>
        <option value="BNB">BNB (BNB)</option>
        <option value="SOL">Solana (SOL)</option>
        <option value="ADA">Кардано (ADA)</option>
        <option value="CRO">Cronos (CRO)</option>
        <option value="DOGE">Dogecoin (DOGE)</option>
        <option value="TRX">TRON (TRX)</option>
        <option value="LEO">LEO Token (LEO)</option>
        <option value="HBAR">Hedera (HBAR)</option>
        <option value="LINK">Chainlink (LINK)</option>
        <option value="XLM">Stellar (XLM)</option>
        <option value="AVAX">Avalanche (AVAX)</option>
        <option value="SUI">Sui (SUI)</option>
        <option value="SHIB">Shiba Inu (SHIB)</option>
        <option value="LTC">Лайткоин (LTC)</option>
        <option value="BCH">Биткойн Кэш (BCH)</option>
        <option value="TON">Toncoin (TON)</option>
        <option value="OM">MANTRA OM (OM)</option>
        <option value="DOT">Polkadot (DOT)</option>
        <option value="BGB">Bitget Token (BGB)</option>
        <option value="HYPE">Hyperliquid (HYPE)</option>
        <option value="WBT">WhiteBIT Coin (WBT)</option>
        <option value="XMR">Монеро (XMR)</option>
        <option value="UNI">Uniswap (UNI)</option>
        <option value="APT">Aptos (APT)</option>
        <option value="NEAR">NEAR Protocol (NEAR)</option>
        <option value="AAVE">Aave (AAVE)</option>
        <option value="ETC">Ethereum Classic (ETC)</option>
      </select>
      <div class="control-buttons">
        <button class="btn btn-secondary" onclick="selectAll()">Выбрать все</button>
        <button class="btn btn-secondary" onclick="deselectAll()">Отменить выбор</button>
        <button class="btn btn-primary" onclick="loadSelectedData()">Загрузить данные</button>
      </div>
    </div>

    <div id="loading" style="display: none;">
      Загрузка данных...<span class="loading-indicator"></span>
      <div id="progress"></div>
    </div>

    <div id="error"></div>

    <!-- Навигация по табам -->
    <ul class="nav nav-tabs" id="myTabs" role="tablist">
      <li class="nav-item">
        <a class="nav-link active" id="sentiment-tab" data-toggle="tab" href="#sentiment" role="tab" aria-controls="sentiment" aria-selected="true">
          Общее настроение рынка
        </a>
      </li>
      <!-- Динамические табы для монет будут добавляться здесь -->
    </ul>

    <div class="tab-content" id="myTabContent">
      <!-- Таб с общим настроением рынка -->
      <div class="tab-pane fade show active" id="sentiment" role="tabpanel" aria-labelledby="sentiment-tab">
        <div class="market-sentiment">
          <div class="d-flex justify-content-between align-items-center mb-3">
            <h2>Общее настроение рынка</h2>
            <button class="btn btn-secondary" onclick="downloadMarketSentimentExcel()">
              Экспорт в Excel
            </button>
          </div>
          <!-- Добавляем контейнер для интерактивного графика -->
          <div class="chart-container" id="marketSentimentChartContainer"></div>
          <table class="table sentiment-table">
            <thead>
              <tr>
                <th>Дата</th>
                <th>Количество бычьих сигналов</th>
                <th>Всего монет с данными</th>
                <th>Процент бычьих сигналов</th>
                <th>13 EMA (%)</th>
                <th>20 SMA (%)</th>
                <th>10 SMA (%)</th>
              </tr>
            </thead>
            <tbody id="sentimentTableBody">
            </tbody>
          </table>
        </div>
      </div>
      <!-- Динамические табы для монет будут добавляться здесь -->
    </div>
  </div>

  <!-- Модальное окно для графика отдельной монеты -->
  <div class="modal fade" id="coinChartModal" tabindex="-1" aria-labelledby="coinChartModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-xl">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="coinChartModalLabel">График монеты</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
          <div id="coinChartContainer" style="position: relative; height: 500px; width: 100%;"></div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-dismiss="modal">Закрыть</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    function formatValue(val) {
      return (val === null || isNaN(val)) ? '-' : Number(val).toFixed(2);
    }

    function show4hValues(values, date) {
      const existingModal = document.querySelector('#fourHourModal');
      if (existingModal) {
        existingModal.remove();
      }

      const modalHtml = `
        <div class="modal fade" id="fourHourModal" tabindex="-1" role="dialog">
          <div class="modal-dialog" role="document">
            <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title">4h значения за ${date}</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                  <span aria-hidden="true">&times;</span>
                </button>
              </div>
              <div class="modal-body">
                <table class="table">
                  <thead>
                    <tr>
                      <th>Время</th>
                      <th>Значение</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${values.map(entry => `
                      <tr>
                        <td>${entry.time}</td>
                        <td>${formatValue(entry.value_new)}</td>
                      </tr>
                    `).join('')}
                  </tbody>
                </table>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Закрыть</button>
              </div>
            </div>
          </div>
        </div>`;

      document.body.insertAdjacentHTML('beforeend', modalHtml);
      $('#fourHourModal').modal('show');
      $('#fourHourModal').on('hidden.bs.modal', function (e) {
        $(this).remove();
      });
    }

    function get4hValuesForDate(row) {
      try {
        if (!row['4h_values_new']) {
          console.error("Missing 4h values arrays");
          return [];
        }
        return row['4h_values_new'].sort((a, b) => a.time.localeCompare(b.time));
      } catch (error) {
        console.error("Error in get4hValuesForDate:", error);
        return [];
      }
    }

    function createTable(symbol, data) {
      const container = document.createElement('div');
      container.className = 'coin-container';

      const exportButton = document.createElement('button');
      exportButton.className = 'btn btn-sm btn-secondary';
      exportButton.innerHTML = 'Экспорт в Excel';
      exportButton.onclick = () => downloadExcel(data, symbol);

      const headerDiv = document.createElement('div');
      headerDiv.style.display = 'flex';
      headerDiv.style.justifyContent = 'space-between';
      headerDiv.style.alignItems = 'center';
      headerDiv.style.marginBottom = '10px';

      const title = document.createElement('h3');
      title.textContent = `${symbol} - DI Index`;

      headerDiv.appendChild(title);
      headerDiv.appendChild(exportButton);
      container.appendChild(headerDiv);

      // Сначала добавляем график
      const chartContainer = document.createElement('div');
      chartContainer.className = 'chart-container';
      const canvas = document.createElement('canvas');
      chartContainer.appendChild(canvas);
      container.appendChild(chartContainer);

      // Затем добавляем таблицу
      const table = document.createElement('table');
      table.className = 'table';
      table.setAttribute('data-sort-dir', 'asc');

      table.innerHTML = `
        <thead>
          <tr>
            <th rowspan="2">Дата</th>
            <th colspan="3" class="group-header">DI Компоненты</th>
            <th colspan="4" class="group-header">Расчет</th>
            <th rowspan="2">Close (Daily)</th>
          </tr>
          <tr>
            <th>Weekly</th>
            <th>Daily</th>
            <th>4h</th>
            <th>Total</th>
            <th>13 EMA</th>
            <th>30 SMA</th>
            <th>Trend</th>
          </tr>
        </thead>
        <tbody>
          ${data.map(row => {
            const values4h = JSON.stringify(get4hValuesForDate(row)).replace(/'/g, "\\'");
            return `
              <tr>
                <td>${row.time}</td>
                <td>${formatValue(row.weekly_di_new)}</td>
                <td>${formatValue(row.daily_di_new)}</td>
                <td style="cursor: pointer" onclick='show4hValues(${values4h}, "${row.time}")'>${formatValue(row['4h_di_new'])}</td>
                <td>${formatValue(row.total_new)}</td>
                <td><span style="cursor: pointer; text-decoration: underline;" onclick='showCoinChart("${symbol}")'>${formatValue(row.di_ema_13_new)}</span></td>
                <td><span style="cursor: pointer; text-decoration: underline;" onclick='showCoinChart("${symbol}")'>${formatValue(row.di_sma_30_new)}</span></td>
                <td><span style="cursor: pointer; text-decoration: underline;" onclick='showCoinChart("${symbol}")'>${row.trend_new ? (row.trend_new === 'bull' ? '<span style="color:green;">bull</span>' : '<span style="color:red;">bear</span>') : '-'}</span></td>
                <td>${formatValue(row.close)}</td>
              </tr>
            `;
          }).join('')}
        </tbody>
      `;

      container.appendChild(table);
      createTrendChart(canvas, data, symbol);

      return container;
    }

    function createTrendChart(canvas, data, symbol) {
      const chartData = [...data].reverse();

      const labels = chartData.map(row => row.time);
      const closeValues = chartData.map(row => parseFloat(row.close));
      const ema13Values = chartData.map(row => parseFloat(row.di_ema_13_new));
      const sma30Values = chartData.map(row => parseFloat(row.di_sma_30_new));
      const trends = chartData.map(row => row.trend_new);

      const ctx = canvas.getContext('2d');
      const gradient = ctx.createLinearGradient(0, 0, 0, 400);
      gradient.addColorStop(0, 'rgba(75, 192, 192, 0.2)');
      gradient.addColorStop(1, 'rgba(75, 192, 192, 0)');

      new Chart(canvas, {
        type: 'line',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Close Price',
              data: closeValues,
              borderColor: 'rgb(75, 192, 192)',
              backgroundColor: gradient,
              fill: true,
              tension: 0.1
            },
            {
              label: '13 EMA',
              data: ema13Values,
              borderColor: 'rgb(255, 99, 132)',
              borderWidth: 2,
              fill: false,
              tension: 0.1
            },
            {
              label: '30 SMA',
              data: sma30Values,
              borderColor: 'rgb(54, 162, 235)',
              borderWidth: 2,
              fill: false,
              tension: 0.1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            title: {
              display: true,
              text: `${symbol} - Trend Analysis`
            },
            tooltip: {
              callbacks: {
                afterBody: function(context) {
                  const index = context[0].dataIndex;
                  const trend = trends[index];
                  return `Trend: ${trend || 'N/A'}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: false,
              title: {
                display: true,
                text: 'Price'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Date'
              }
            }
          }
        }
      });
    }

    function createCoinTab(symbol, data) {
      const tabId = `coin-${symbol}`;
      const tabLink = document.createElement('li');
      tabLink.className = 'nav-item';
      tabLink.innerHTML = `
        <a class="nav-link" id="${tabId}-tab" data-toggle="tab" href="#${tabId}" role="tab" 
           aria-controls="${tabId}" aria-selected="false">
          ${symbol}
        </a>
      `;

      const tabContent = document.createElement('div');
      tabContent.className = 'tab-pane fade';
      tabContent.id = tabId;
      tabContent.setAttribute('role', 'tabpanel');
      tabContent.setAttribute('aria-labelledby', `${tabId}-tab`);

      const table = createTable(symbol, data);
      tabContent.appendChild(table);

      return { tabLink, tabContent };
    }

    function downloadExcel(data, symbol) {
      const rows = [
        ['Дата', 
         'Weekly DI', 'Daily DI', '4h DI',
         'Total', '13 EMA', '30 SMA', 'Trend',
         'Close (Daily)']
      ];

      data.forEach(row => {
        rows.push([
          row.time,
          formatValue(row.weekly_di_new),
          formatValue(row.daily_di_new),
          formatValue(row['4h_di_new']),
          formatValue(row.total_new),
          formatValue(row.di_ema_13_new),
          formatValue(row.di_sma_30_new),
          row.trend_new || '-',
          formatValue(row.close)
        ]);
      });

      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(rows);
      XLSX.utils.book_append_sheet(wb, ws, symbol);
      XLSX.writeFile(wb, `${symbol}_DI_Index_${new Date().toISOString().split('T')[0]}.xlsx`);
    }

    function selectAll() {
      const symbolsSelect = document.getElementById('symbols');
      for (let option of symbolsSelect.options) {
        option.selected = true;
      }
    }

    function deselectAll() {
      const symbolsSelect = document.getElementById('symbols');
      for (let option of symbolsSelect.options) {
        option.selected = false;
      }
    }

    function clearAllTabs() {
      const tabList = document.getElementById('myTabs');
      const tabContent = document.getElementById('myTabContent');

      const sentimentTab = document.getElementById('sentiment-tab').parentElement;
      const sentimentContent = document.getElementById('sentiment');

      tabList.innerHTML = '';
      tabList.appendChild(sentimentTab);

      tabContent.innerHTML = '';
      tabContent.appendChild(sentimentContent);
    }

    async function loadSelectedData() {
      const loadingDiv = document.getElementById('loading');
      const progressDiv = document.getElementById('progress');
      const errorDiv = document.getElementById('error');

      try {
        loadingDiv.style.display = 'block';
        errorDiv.textContent = '';
        clearAllTabs();

        const symbolsSelect = document.getElementById('symbols');
        const selectedSymbols = Array.from(symbolsSelect.selectedOptions).map(option => option.value);

        if (selectedSymbols.length === 0) {
          throw new Error('Пожалуйста, выберите хотя бы одну криптовалюту');
        }

        const tabList = document.getElementById('myTabs');
        const tabContent = document.getElementById('myTabContent');

        const batches = batchProcess(selectedSymbols, 3);
        let successCount = 0;
        let errorCount = 0;
        let allData = {};

        for (let i = 0; i < batches.length; i++) {
          const batch = batches[i];
          progressDiv.textContent = `Загрузка пакета ${i + 1} из ${batches.length} (${batch.join(', ')})...`;

          let retryCount = 0;
          const maxRetries = 3;

          while (retryCount < maxRetries) {
            try {
              const response = await fetch(`/api/di_index?symbols=${batch.join(',')}`);
              if (!response.ok) {
                throw new Error(`HTTP error: ${response.status}`);
              }

              const json = await response.json();
              Object.assign(allData, json);

              for (const [symbol, data] of Object.entries(json)) {
                if (Array.isArray(data)) {
                  const { tabLink, tabContent: content } = createCoinTab(symbol, data);
                  tabList.appendChild(tabLink);
                  tabContent.appendChild(content);
                  successCount++;
                } else if (data.error) {
                  console.error(`Ошибка для ${symbol}:`, data.error);
                  errorDiv.textContent += `Ошибка для ${symbol}: ${data.error}\n`;
                  errorCount++;
                }
              }
              break;

            } catch (error) {
              retryCount++;
              if (retryCount === maxRetries) {
                console.error(`Error processing batch ${i + 1}:`, error);
                errorDiv.textContent += `Ошибка в пакете ${i + 1} (${batch.join(', ')}): ${error.message}\n`;
                errorCount += batch.length;
              } else {
                console.log(`Retry ${retryCount} of ${maxRetries} for batch ${i + 1}...`);
                await new Promise(resolve => setTimeout(resolve, 1000 * retryCount));
              }
            }
          }
        }

        if (Object.keys(allData).length > 0) {
          const sentimentData = calculateMarketSentiment(allData);
          updateSentimentTable(sentimentData);
        }

        progressDiv.textContent = `Загружено успешно: ${successCount} монет, с ошибками: ${errorCount} монет`;

        const firstCoinTab = tabList.querySelector('li:nth-child(2) a');
        if (firstCoinTab) {
          firstCoinTab.click();
        }

      } catch (error) {
        console.error("Error loading data:", error);
        errorDiv.textContent = `Ошибка загрузки данных: ${error.message}`;
        progressDiv.textContent = '';
      } finally {
        loadingDiv.style.display = 'none';
      }
    }

    window.onload = loadSelectedData;

    function downloadMarketSentimentExcel() {
      const rows = [
        ['Дата', 'Количество бычьих сигналов', 'Всего монет с данными', 'Процент бычьих сигналов', '13 EMA (%)', '20 SMA (%)', '10 SMA (%)']
      ];

      const tbody = document.getElementById('sentimentTableBody');
      const tableRows = tbody.getElementsByTagName('tr');

      Array.from(tableRows).forEach(row => {
        const cells = row.getElementsByTagName('td');
        rows.push([
          cells[0].textContent,
          cells[1].textContent,
          cells[2].textContent,
          cells[3].textContent,
          cells[4].textContent,
          cells[5].textContent,
          cells[6].textContent
        ]);
      });

      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(rows);
      XLSX.utils.book_append_sheet(wb, ws, "Market Sentiment");
      XLSX.writeFile(wb, `Market_Sentiment_${new Date().toISOString().split('T')[0]}.xlsx`);
    }

    function calculateMarketSentiment(allData) {
      const sentimentByDate = {};

      for (const [symbol, data] of Object.entries(allData)) {
        if (!Array.isArray(data)) continue;

        data.forEach(row => {
          const date = row.time;
          if (!sentimentByDate[date]) {
            sentimentByDate[date] = { bullCount: 0, totalCount: 0 };
          }
          if (row.trend_new !== null) {
            sentimentByDate[date].totalCount++;
            if (row.trend_new === 'bull') {
              sentimentByDate[date].bullCount++;
            }
          }
        });
      }

      const sortedData = Object.entries(sentimentByDate)
        .map(([date, data]) => ({
          date,
          bullCount: data.bullCount,
          totalCount: data.totalCount,
          percentage: (data.bullCount / data.totalCount * 100).toFixed(2)
        }))
        .sort((a, b) => a.date.localeCompare(b.date));

      const percentages = sortedData.map(item => parseFloat(item.percentage));
      const ma13 = [];
      const sma20 = [];
      const sma10 = [];
      const alpha = 2 / (13 + 1);

      for (let i = 0; i < percentages.length; i++) {
        if (isNaN(percentages[i])) {
          ma13.push(null);
          sma20.push(null);
          sma10.push(null);
        } else if (i === 0) {
          ma13.push(parseFloat(percentages[i]));
          sma20.push(parseFloat(percentages[i]));
          sma10.push(parseFloat(percentages[i]));
        } else {
          // Calculate 13 EMA
          const prevEMA = ma13[i - 1];
          if (prevEMA === null || isNaN(prevEMA)) {
            ma13.push(parseFloat(percentages[i]));
          } else {
            const ema = (percentages[i] * alpha) + (prevEMA * (1 - alpha));
            ma13.push(ema);
          }

          // Calculate 20 SMA
          const start20 = Math.max(0, i - 19);
          const slice20 = percentages.slice(start20, i + 1);
          const validNumbers20 = slice20.filter(n => !isNaN(n));
          sma20.push(validNumbers20.length > 0 ? 
            validNumbers20.reduce((a, b) => a + b, 0) / validNumbers20.length : 
            null
          );

          // Calculate 10 SMA
          const start10 = Math.max(0, i - 9);
          const slice10 = percentages.slice(start10, i + 1);
          const validNumbers10 = slice10.filter(n => !isNaN(n));
          sma10.push(validNumbers10.length > 0 ? 
            validNumbers10.reduce((a, b) => a + b, 0) / validNumbers10.length : 
            null
          );
        }
      }

      return sortedData.map((item, index) => ({
        ...item,
        ma13: ma13[index] === null ? null : ma13[index].toFixed(2),
        sma20: sma20[index] === null ? null : sma20[index].toFixed(2),
        sma10: sma10[index] === null ? null : sma10[index].toFixed(2)
      })).reverse();
    }

    function updateSentimentTable(sentimentData) {
      const tbody = document.getElementById('sentimentTableBody');
      tbody.innerHTML = sentimentData.map(row => `
        <tr>
          <td>${row.date}</td>
          <td>${row.bullCount}</td>
          <td>${row.totalCount}</td>
          <td>${row.percentage}%</td>
          <td>${row.ma13 !== null ? row.ma13 + '%' : '-'}</td>
          <td>${row.sma20 !== null ? row.sma20 + '%' : '-'}</td>
          <td>${row.sma10 !== null ? row.sma10 + '%' : '-'}</td>
        </tr>
      `).join('');

      // Создаем TradingView-подобный график с LightweightCharts
      const chartContainer = document.getElementById('marketSentimentChartContainer');
      chartContainer.innerHTML = ''; // Очищаем контейнер перед созданием нового графика
      
      // Создаем инстанс графика
      const chart = LightweightCharts.createChart(chartContainer, {
        width: chartContainer.clientWidth,
        height: 400,
        layout: {
          backgroundColor: '#ffffff',
          textColor: '#333',
          fontSize: 12,
          fontFamily: 'Arial',
        },
        grid: {
          vertLines: {
            color: 'rgba(225, 225, 225, 0.8)',
          },
          horzLines: {
            color: 'rgba(225, 225, 225, 0.8)',
          },
        },
        crosshair: {
          mode: 1, // CrosshairMode.Normal
          vertLine: {
            color: 'rgba(100, 100, 100, 0.4)',
            width: 1,
            style: 1, // LineStyle.Dashed
          },
          horzLine: {
            color: 'rgba(100, 100, 100, 0.4)',
            width: 1,
            style: 1, // LineStyle.Dashed
            labelBackgroundColor: 'rgba(100, 100, 100, 0.8)',
          },
        },
        timeScale: {
          borderColor: 'rgba(200, 200, 200, 1)',
          timeVisible: true,
          secondsVisible: false,
          tickMarkFormatter: (time) => {
            const date = new Date(time * 1000);
            return date.toLocaleDateString('ru-RU', {
              month: '2-digit',
              day: '2-digit',
            });
          },
          rightOffset: 5,
          barSpacing: 12,
          fixLeftEdge: true,
          lockVisibleTimeRangeOnResize: true,
          rightBarStaysOnScroll: true,
          visible: true,
          borderVisible: true,
        },
        rightPriceScale: {
          borderColor: 'rgba(200, 200, 200, 1)',
          scaleMargins: {
            top: 0.1,
            bottom: 0.1,
          },
        },
      });
      
      // Добавляем линию для процента бычьих сигналов
      const percentageSeries = chart.addLineSeries({
        title: 'Процент бычьих сигналов',
        color: 'rgb(75, 192, 192)',
        lineWidth: 2,
        priceFormat: {
          type: 'percent',
          precision: 2,
        },
      });
      
      // Добавляем линию для 10 SMA
      const sma10Series = chart.addLineSeries({
        title: '10 SMA',
        color: 'rgb(255, 206, 86)',
        lineWidth: 3,
        priceFormat: {
          type: 'percent',
          precision: 2,
        },
      });
      
      // Подготовка данных для отображения
      // Используем исходные данные (от старых к новым) для LightweightCharts
      const chartData = [...sentimentData].reverse();
      
      // Подготавливаем точки данных для каждой серии
      const percentageData = chartData.map(row => {
        // Преобразуем дату в формат timestamp для LightweightCharts
        const dateParts = row.date.split('.');
        if (dateParts.length === 3) {
          // Если формат даты dd.mm.yyyy
          const day = parseInt(dateParts[0]);
          const month = parseInt(dateParts[1]) - 1; // Месяцы в JS начинаются с 0
          const year = parseInt(dateParts[2]);
          const timestamp = Math.floor(new Date(year, month, day).getTime() / 1000);
          return {
            time: timestamp,
            value: parseFloat(row.percentage),
          };
        } else {
          // Если другой формат даты, пробуем стандартный парсинг
          const date = new Date(row.date);
          return {
            time: Math.floor(date.getTime() / 1000),
            value: parseFloat(row.percentage),
          };
        }
      });
      
      const sma10Data = chartData.map(row => {
        if (row.sma10 === null) return null;
        
        // Преобразуем дату в формат timestamp для LightweightCharts
        const dateParts = row.date.split('.');
        if (dateParts.length === 3) {
          // Если формат даты dd.mm.yyyy
          const day = parseInt(dateParts[0]);
          const month = parseInt(dateParts[1]) - 1; // Месяцы в JS начинаются с 0
          const year = parseInt(dateParts[2]);
          const timestamp = Math.floor(new Date(year, month, day).getTime() / 1000);
          return {
            time: timestamp,
            value: parseFloat(row.sma10),
          };
        } else {
          // Если другой формат даты, пробуем стандартный парсинг
          const date = new Date(row.date);
          return {
            time: Math.floor(date.getTime() / 1000),
            value: parseFloat(row.sma10),
          };
        }
      }).filter(point => point !== null);
      
      // Устанавливаем данные для обеих серий
      percentageSeries.setData(percentageData);
      sma10Series.setData(sma10Data);
      
      // Добавляем панель легенды
      const legendContainer = document.createElement('div');
      legendContainer.style.position = 'absolute';
      legendContainer.style.left = '12px';
      legendContainer.style.top = '12px';
      legendContainer.style.zIndex = '1';
      legendContainer.style.fontSize = '12px';
      legendContainer.style.fontFamily = 'Arial';
      legendContainer.style.lineHeight = '18px';
      legendContainer.style.fontWeight = 'bold';
      legendContainer.style.padding = '8px';
      legendContainer.style.background = 'rgba(255, 255, 255, 0.7)';
      legendContainer.style.color = '#333';
      legendContainer.style.borderRadius = '3px';
      chartContainer.appendChild(legendContainer);
      
      // Начальное содержимое легенды
      let legendText = '<div style="font-size: 14px; margin-bottom: 8px;">Соотношение текущих бычьих сигналов и 10 SMA</div>';
      legendText += '<div style="margin-bottom: 5px;">Наведите курсор на график для просмотра значений</div>';
      legendText += `<div style="color: rgb(75, 192, 192); margin-bottom: 3px;">Процент бычьих сигналов</div>`;
      legendText += `<div style="color: rgb(255, 206, 86);">10 SMA</div>`;
      legendContainer.innerHTML = legendText;
      
      // Обработчик для обновления легенды при наведении курсора
      chart.subscribeCrosshairMove((param) => {
        if (
          param.point === undefined ||
          !param.time ||
          param.point.x < 0 ||
          param.point.x > chartContainer.clientWidth ||
          param.point.y < 0 ||
          param.point.y > chartContainer.clientHeight
        ) {
          // Если курсор за пределами графика, показываем общую информацию
          legendText = '<div style="font-size: 14px; margin-bottom: 8px;">Соотношение текущих бычьих сигналов и 10 SMA</div>';
          legendText += '<div style="margin-bottom: 5px;">Наведите курсор на график для просмотра значений</div>';
          legendText += `<div style="color: rgb(75, 192, 192); margin-bottom: 3px;">Процент бычьих сигналов</div>`;
          legendText += `<div style="color: rgb(255, 206, 86);">10 SMA</div>`;
          legendContainer.innerHTML = legendText;
        } else {
          // Иначе показываем значение под курсором
          const timestamp = param.time;
          
          // Находим соответствующую точку данных
          const percentagePoint = percentageData.find(p => p.time === timestamp);
          const sma10Point = sma10Data.find(p => p.time === timestamp);
          
          // Форматирование даты из timestamp
          const date = new Date(timestamp * 1000);
          const dateStr = date.toLocaleDateString('ru-RU', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit'
          });
          
          legendText = '<div style="font-size: 14px; margin-bottom: 8px;">Соотношение текущих бычьих сигналов и 10 SMA</div>';
          legendText += `<div style="margin-bottom: 5px;">Дата: ${dateStr}</div>`;
          
          if (percentagePoint) {
            legendText += `<div style="color: rgb(75, 192, 192); margin-bottom: 3px;">Процент бычьих сигналов: ${percentagePoint.value.toFixed(2)}%</div>`;
          }
          
          if (sma10Point) {
            legendText += `<div style="color: rgb(255, 206, 86);">10 SMA: ${sma10Point.value.toFixed(2)}%</div>`;
          }
          
          legendContainer.innerHTML = legendText;
        }
      });
      
      // Адаптивность по размеру окна
      window.addEventListener('resize', () => {
        chart.applyOptions({
          width: chartContainer.clientWidth,
        });
      });
      
      // Подгоняем масштаб, чтобы видеть все данные
      chart.timeScale().fitContent();
    }

    function batchProcess(symbols, batchSize = 5) {
      const batches = [];
      for (let i = 0; i < symbols.length; i += batchSize) {
        batches.push(symbols.slice(i, i + batchSize));
      }
      return batches;
    }

    async function showCoinChart(symbol) {
      // Устанавливаем заголовок модального окна
      document.getElementById('coinChartModalLabel').textContent = `${symbol} - Загрузка данных...`;
      
      // Показываем модальное окно
      $('#coinChartModal').modal('show');
      
      // Получаем контейнер для графика
      const chartContainer = document.getElementById('coinChartContainer');
      chartContainer.innerHTML = '<div class="text-center my-5"><div class="spinner-border" role="status"><span class="sr-only">Загрузка...</span></div><p class="mt-3">Загрузка данных...</p></div>'; 
      
      try {
        // Загружаем данные для конкретного символа
        const response = await fetch(`/api/di_index?symbols=${symbol}`);
        if (!response.ok) {
          throw new Error(`HTTP error: ${response.status}`);
        }
        
        const json = await response.json();
        if (!json[symbol] || !Array.isArray(json[symbol])) {
          throw new Error(`Данные для ${symbol} не найдены или имеют неверный формат`);
        }
        
        // Обновляем заголовок
        document.getElementById('coinChartModalLabel').textContent = `${symbol} - TradingView График`;
        
        // Очищаем контейнер
        chartContainer.innerHTML = '';
        
        // Отсортированные от старых к новым данные
        const chartData = [...json[symbol]].sort((a, b) => a.time.localeCompare(b.time));
      
      // Создаем TradingView график
      const chart = LightweightCharts.createChart(chartContainer, {
        width: chartContainer.clientWidth,
        height: 500,
        layout: {
          backgroundColor: '#ffffff',
          textColor: '#333',
          fontSize: 12,
          fontFamily: 'Arial',
        },
        grid: {
          vertLines: {
            color: 'rgba(225, 225, 225, 0.8)',
          },
          horzLines: {
            color: 'rgba(225, 225, 225, 0.8)',
          },
        },
        crosshair: {
          mode: 1, // CrosshairMode.Normal
          vertLine: {
            color: 'rgba(100, 100, 100, 0.4)',
            width: 1,
            style: 1, // LineStyle.Dashed
          },
          horzLine: {
            color: 'rgba(100, 100, 100, 0.4)',
            width: 1,
            style: 1, // LineStyle.Dashed
            labelBackgroundColor: 'rgba(100, 100, 100, 0.8)',
          },
        },
        timeScale: {
          borderColor: 'rgba(200, 200, 200, 1)',
          timeVisible: true,
          secondsVisible: false,
          tickMarkFormatter: (time) => {
            const date = new Date(time * 1000);
            return date.toLocaleDateString('ru-RU', {
              month: '2-digit',
              day: '2-digit',
            });
          },
          rightOffset: 5,
          barSpacing: 12,
          fixLeftEdge: true,
          lockVisibleTimeRangeOnResize: true,
          rightBarStaysOnScroll: true,
          visible: true,
          borderVisible: true,
        },
        rightPriceScale: {
          borderColor: 'rgba(200, 200, 200, 1)',
          scaleMargins: {
            top: 0.1,
            bottom: 0.1,
          },
        },
      });

      // Создаем серию для свечей цены
      const candleSeries = chart.addCandlestickSeries({
        upColor: '#26a69a',
        downColor: '#ef5350',
        borderVisible: false,
        wickUpColor: '#26a69a',
        wickDownColor: '#ef5350',
      });

      // Создаем серию для 13 EMA
      const ema13Series = chart.addLineSeries({
        title: '13 EMA',
        color: 'rgb(255, 99, 132)',
        lineWidth: 2,
        priceFormat: {
          type: 'price',
          precision: 2,
          minMove: 0.01,
        },
      });

      // Создаем серию для 30 SMA
      const sma30Series = chart.addLineSeries({
        title: '30 SMA',
        color: 'rgb(54, 162, 235)',
        lineWidth: 2,
        priceFormat: {
          type: 'price',
          precision: 2,
          minMove: 0.01,
        },
      });

      // Создаем серию для линии тренда
      const trendSeries = chart.addLineSeries({
        title: 'Trend',
        lineWidth: 2,
        color: 'rgba(0, 0, 0, 0)', // Прозрачная линия, так как будем показывать только маркеры
        lastPriceAnimation: 0,
      });

      // Подготавливаем данные для свечей
      const candleData = chartData.map(row => {
        // Преобразуем дату в формат timestamp для LightweightCharts
        const dateParts = row.time.split('.');
        let timestamp;
        if (dateParts.length === 3) {
          // Если формат даты dd.mm.yyyy
          const day = parseInt(dateParts[0]);
          const month = parseInt(dateParts[1]) - 1; // Месяцы в JS начинаются с 0
          const year = parseInt(dateParts[2]);
          timestamp = Math.floor(new Date(year, month, day).getTime() / 1000);
        } else {
          // Если другой формат даты, пробуем стандартный парсинг
          timestamp = Math.floor(new Date(row.time).getTime() / 1000);
        }
        
        // Генерируем данные для свечи
        // Обычно у нас есть только close, поэтому open/high/low оцениваем примерно
        const close = parseFloat(row.close);
        const open = close * (1 - Math.random() * 0.02); // Примерно на 0-2% меньше
        return {
          time: timestamp,
          open: open,
          high: Math.max(open, close) * (1 + Math.random() * 0.01), // Чуть выше
          low: Math.min(open, close) * (1 - Math.random() * 0.01), // Чуть ниже
          close: close
        };
      });

      // Подготавливаем данные для 13 EMA
      const ema13Data = chartData.map(row => {
        const dateParts = row.time.split('.');
        let timestamp;
        if (dateParts.length === 3) {
          const day = parseInt(dateParts[0]);
          const month = parseInt(dateParts[1]) - 1;
          const year = parseInt(dateParts[2]);
          timestamp = Math.floor(new Date(year, month, day).getTime() / 1000);
        } else {
          timestamp = Math.floor(new Date(row.time).getTime() / 1000);
        }
        
        return {
          time: timestamp,
          value: parseFloat(row.di_ema_13_new)
        };
      });

      // Подготавливаем данные для 30 SMA
      const sma30Data = chartData.map(row => {
        const dateParts = row.time.split('.');
        let timestamp;
        if (dateParts.length === 3) {
          const day = parseInt(dateParts[0]);
          const month = parseInt(dateParts[1]) - 1;
          const year = parseInt(dateParts[2]);
          timestamp = Math.floor(new Date(year, month, day).getTime() / 1000);
        } else {
          timestamp = Math.floor(new Date(row.time).getTime() / 1000);
        }
        
        return {
          time: timestamp,
          value: parseFloat(row.di_sma_30_new)
        };
      });

      // Подготавливаем данные для трендовой линии
      const trendData = chartData.map(row => {
        const dateParts = row.time.split('.');
        let timestamp;
        if (dateParts.length === 3) {
          const day = parseInt(dateParts[0]);
          const month = parseInt(dateParts[1]) - 1;
          const year = parseInt(dateParts[2]);
          timestamp = Math.floor(new Date(year, month, day).getTime() / 1000);
        } else {
          timestamp = Math.floor(new Date(row.time).getTime() / 1000);
        }
        
        // Значение берем как среднее между ema13 и sma30 для наглядности
        return {
          time: timestamp,
          value: (parseFloat(row.di_ema_13_new) + parseFloat(row.di_sma_30_new)) / 2,
          color: row.trend_new === 'bull' ? 'green' : (row.trend_new === 'bear' ? 'red' : 'gray'),
          shape: 'circle',
          size: 1
        };
      });

      // Устанавливаем данные для всех серий
      candleSeries.setData(candleData);
      ema13Series.setData(ema13Data);
      sma30Series.setData(sma30Data);
      
      // Для тренда добавляем и маркеры
      trendSeries.setData([]);
      
      // Добавляем маркеры для трендовой линии
      trendData.forEach(point => {
        trendSeries.createPriceLine({
          price: point.value,
          time: point.time,
          color: point.color,
          lineWidth: 1,
          lineStyle: 2, // Штриховая линия
          axisLabelVisible: false,
          title: point.trend === 'bull' ? 'Bull' : (point.trend === 'bear' ? 'Bear' : ''),
        });
      });

      // Добавляем панель легенды
      const legendContainer = document.createElement('div');
      legendContainer.style.position = 'absolute';
      legendContainer.style.left = '12px';
      legendContainer.style.top = '12px';
      legendContainer.style.zIndex = '1';
      legendContainer.style.fontSize = '12px';
      legendContainer.style.fontFamily = 'Arial';
      legendContainer.style.lineHeight = '18px';
      legendContainer.style.fontWeight = 'bold';
      legendContainer.style.padding = '8px';
      legendContainer.style.background = 'rgba(255, 255, 255, 0.7)';
      legendContainer.style.color = '#333';
      legendContainer.style.borderRadius = '3px';
      chartContainer.appendChild(legendContainer);
      
      // Начальное содержимое легенды
      let legendText = `<div style="font-size: 14px; margin-bottom: 8px;">${symbol} - Тренд анализ</div>`;
      legendText += '<div style="margin-bottom: 5px;">Наведите курсор на график для просмотра значений</div>';
      legendText += `<div style="color: rgb(0, 0, 0); margin-bottom: 3px;">Цена закрытия</div>`;
      legendText += `<div style="color: rgb(255, 99, 132); margin-bottom: 3px;">13 EMA</div>`;
      legendText += `<div style="color: rgb(54, 162, 235); margin-bottom: 3px;">30 SMA</div>`;
      legendText += `<div><span style="color: green;">●</span> Bull | <span style="color: red;">●</span> Bear</div>`;
      legendContainer.innerHTML = legendText;
      
      // Обработчик для обновления легенды при наведении курсора
      chart.subscribeCrosshairMove((param) => {
        if (
          param.point === undefined ||
          !param.time ||
          param.point.x < 0 ||
          param.point.x > chartContainer.clientWidth ||
          param.point.y < 0 ||
          param.point.y > chartContainer.clientHeight
        ) {
          // Если курсор за пределами графика, показываем общую информацию
          legendText = `<div style="font-size: 14px; margin-bottom: 8px;">${symbol} - Тренд анализ</div>`;
          legendText += '<div style="margin-bottom: 5px;">Наведите курсор на график для просмотра значений</div>';
          legendText += `<div style="color: rgb(0, 0, 0); margin-bottom: 3px;">Цена закрытия</div>`;
          legendText += `<div style="color: rgb(255, 99, 132); margin-bottom: 3px;">13 EMA</div>`;
          legendText += `<div style="color: rgb(54, 162, 235); margin-bottom: 3px;">30 SMA</div>`;
          legendText += `<div><span style="color: green;">●</span> Bull | <span style="color: red;">●</span> Bear</div>`;
          legendContainer.innerHTML = legendText;
        } else {
          // Иначе показываем значение под курсором
          const timestamp = param.time;
          
          // Находим соответствующую точку данных
          const candlePoint = candleData.find(p => p.time === timestamp);
          const ema13Point = ema13Data.find(p => p.time === timestamp);
          const sma30Point = sma30Data.find(p => p.time === timestamp);
          const trendPoint = trendData.find(p => p.time === timestamp);
          
          // Форматирование даты из timestamp
          const date = new Date(timestamp * 1000);
          const dateStr = date.toLocaleDateString('ru-RU', {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit'
          });
          
          legendText = `<div style="font-size: 14px; margin-bottom: 8px;">${symbol} - Тренд анализ</div>`;
          legendText += `<div style="margin-bottom: 5px;">Дата: ${dateStr}</div>`;
          
          if (candlePoint) {
            legendText += `<div style="color: rgb(0, 0, 0); margin-bottom: 3px;">Цена закрытия: ${candlePoint.close.toFixed(2)}</div>`;
          }
          
          if (ema13Point) {
            legendText += `<div style="color: rgb(255, 99, 132); margin-bottom: 3px;">13 EMA: ${ema13Point.value.toFixed(2)}</div>`;
          }
          
          if (sma30Point) {
            legendText += `<div style="color: rgb(54, 162, 235); margin-bottom: 3px;">30 SMA: ${sma30Point.value.toFixed(2)}</div>`;
          }
          
          if (trendPoint) {
            const trendText = trendPoint.color === 'green' ? 'Bull' : (trendPoint.color === 'red' ? 'Bear' : 'Neutral');
            legendText += `<div style="color: ${trendPoint.color};">Trend: ${trendText}</div>`;
          }
          
          legendContainer.innerHTML = legendText;
        }
      });
      
      // Адаптивность по размеру окна
      const resizeObserver = new ResizeObserver(entries => {
        chart.applyOptions({
          width: chartContainer.clientWidth,
        });
      });
      resizeObserver.observe(chartContainer);
      
      // Подгоняем масштаб, чтобы видеть все данные
      chart.timeScale().fitContent();
      
      // Показываем модальное окно
      $('#coinChartModal').modal('show');
      
      // Очищаем наблюдателя за размером при закрытии модального окна
      $('#coinChartModal').on('hidden.bs.modal', function (e) {
        resizeObserver.disconnect();
      });
      } catch (error) {
        console.error("Error creating chart:", error);
        chartContainer.innerHTML = `<div class="alert alert-danger mt-3">
          <h4 class="alert-heading">Ошибка загрузки данных</h4>
          <p>${error.message}</p>
          <hr>
          <p class="mb-0">Пожалуйста, попробуйте еще раз или выберите другую монету.</p>
        </div>`;
      }
    }
  </script>
</body>
</html>